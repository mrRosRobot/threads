Понятно, делаем «минималку» — только самое простое, чтобы дети увидели параллельность и асинхронность.

---

## 1. Коротко о потоках

- **Поток (thread)** — это отдельная «линия выполнения» внутри одной программы.  
- При `t.start()` запускается новый поток, он «параллельно» выполняет вашу функцию до `t.join()`, когда главный поток ждёт его окончания.  
- `time.sleep()` внутри потока показывает, что пока мы «спим», другой поток может работать.

### Пример: два потока с задержками

```python
import threading
import time

def worker(name, delay):
    for i in range(3):
        print(f"[{name}] шаг {i}")   # что печатает этот поток
        time.sleep(delay)            # жмём паузу — GIL отпускается, другой поток бежит
    print(f"[{name}] завершился")

# создаём два потока с разной задержкой
t1 = threading.Thread(target=worker, args=("T1", 1))
t2 = threading.Thread(target=worker, args=("T2", 0.5))

t1.start()   # запускаем T1
t2.start()   # запускаем T2
t1.join()    # ждём, пока T1 отработает
t2.join()    # ждём, пока T2 отработает

print("Оба потока завершились")
```

**Что будет в итоге?**:  
- T2, у которого delay=0.5, будет печатать два раза чаще, чем T1.  
- Вывод двух потоков будет перемешан — это и есть простая «параллельность».

---

## 2. Коротко об асинхронности (`asyncio`)

- Асинхронность позволяет запускать функции, которые сами «отдают ход» (через `await`), не создавая потоки.  
- При `await asyncio.sleep()` цикл событий переключится на другую корутину.

### Пример: две async-функции

```python
import asyncio

async def task(name, delay):
    print(f"{name} начался")
    await asyncio.sleep(delay)    # ждём, но не блокируем остальное
    print(f"{name} завершился")

async def main():
    # запустим обе задачи «одновременно»
    await asyncio.gather(
        task("A", 1),
        task("B", 0.5),
    )
    print("Все async-задачи завершены")

asyncio.run(main())
```

**Что увидим в итоге?**:  
- «B» завершится раньше, потому что delay=0.5.  
- Вывод функций тоже будет перемешан, но без создания потоков.

---

## 3. Простые задания

**Задание 1.**  
Создайте два потока, которые по 5 раз выводят «Ping» и «Pong» с задержкой 0.7 и 1 секунду соответственно.



---

**Задание 2.**  
Измените предыдущую программу так, чтобы главный поток не ждал: после `t1.start()` и `t2.start()` сразу печаталось «Главный поток дальше работает».



---

**Задание 3.**  
Напишите две async-функции `hello()` и `world()`, где `hello` ждёт 1 секунду перед `print("Hello")`, а `world` — 0.5 секунды перед `print("World")`. Запустите их вместе.


---

**Задание 4.**  
Добавьте в `main()` после `gather` строку `print("Done")` и проверьте, что она выводится после слов «Hello» и «World».

<details>
<summary>Решение</summary>

```python
async def main():
    await asyncio.gather(hello(), world())
    print("Done")  # здесь
```
</details>
